The decoding problem in Statistical Machine Translation (SMT) is a computationally hard combinatorial optimization problem. In this paper, we propose a new algorithmic framework for solving the decoding problem and demonstrate its utility. In the new algorithmic framework, the decoding problem can be solved both exactly and approximately. The key idea behind the framework is the modeling of the decoding problem as one that involves alternating maximization of two relatively simpler subproblems. We show how the subproblems can be solved efficiently and how their solutions can be combined to arrive at a solution for the decoding problem. A family of provably fast decoding algorithms can be derived from the basic techniques underlying the framework and we present a few illustrations. Our first algorithm is a provably linear time search algorithm. We use this algorithm as a subroutine in the other algorithms. We believe that decoding algorithms derived from our framework can be of practical significance.

 Decoding is one of the three fundamental problems in classical SMT (translation model and language model being the other two) as proposed by IBM in the early 1990s (Brown et al 1993 In the decoding problem we are given the language and translation models and a source language sentence and are asked to find the most probable translation for the sentence. De coding is a discrete optimization problem whose search space is prohibitively large. The challenge is, therefore, in devising a scheme to efficiently search the solution space for the solution. Decoding is known to belong to a class of computational problems popularly known as NPhard problems (Knight, 1999 NP-hard problems are known to be computationally hard and have eluded polynomial time algorithms (Garey and Johnson, 1979 The first algorithms for the decoding problem were based on what is known among the speech recognition community as stack-based search (Jelinek, 1969 The original IBM solution to the decoding problem employed a restricted stack-based search (Berger et al 1996 This idea was further explored by Wang and Waibel (Wang and Waibel, 1997) who developed a faster stack-based search algorithm. In perhaps the first work on the computational complexity of Decoding, Kevin Knight showed that the problem is closely related to the more famous Traveling Salesman problem (TSP Independently, Christoph Tillman adapted the Held-Karp dynamic programming algorithm for TSP (Held and Karp, 1962) to Decoding (Tillman, 2001 The original HeldKarp algorithm for TSP is an exponential time dynamic programming algorithm and Tillmans adaptation to Decoding has a prohibitive com plexity of O (l3m2 2m )O (m5 2m (where m and l are the lengths of the source and tar get sentences respectively Tillman and Ney showed how to improve the complexity of the Held-Karp algorithm for restricted word re ordering and gave a O (l3m4)O (m7) algo rithm for French-English translation (Tillman and Ney, 2000 An optimal decoder based on the well-known A heuristic was implemented and benchmarked in (Och et al 2001 Since optimal solution can not be computed for practical problem instances in a reasonable amount of time, much of recent work has focused on good quality suboptimal solutions. An O (m6) greedy search algorithm was developed (Germann et al 2003) whose complexity was re duced further to O (m2 Germann, 2003 In this paper, we propose an algorithmic framework for solving the decoding problem and show that several efficient decoding algorithms can be derived from the techniques developed in the framework. We model the search problem as an alternating search problem. The search, therefore, alternates between two subproblems, both of which are much easier to solve in practice. By breaking the decoding problem into two simpler search problems, we are able to provide handles for solving the problem efficiently. The solutions of the subproblems can be combined easily to arrive at a solution for the original problem. The first subproblem fixes an alignment and seeks the best translation with that alignment. Starting with an initial alignment between the source sentence and its translation, the second subproblem asks for an improved alignment. We show that both of these problems are easy to solve and provide efficient solutions for them. In an iterative search for a local optimal solution, we alternate between the two algorithms and refine our solution. The algorithmic framework provides handles for solving the decoding problem at several levels of complexity. At one extreme, the framework yields an algorithm for solving the decoding problem optimally. At the other extreme, it yields a provably linear time algorithm for finding suboptimal solutions to the problem. We show that the algorithmic handles provided by our framework can be employed to develop a very fast decoding algorithm which finds good quality translations. Our fast suboptimal search algorithms can translate sentences that are 50 words long in about 5 seconds on a simple computing facility. The rest of the paper is devoted to the development and discussion of our framework. We start with a mathematical formulation of the decoding problem (Section 2 We then develop the alternating search paradigm and use it to develop several decoding algorithms (Section 3 Next, we demonstrate the practical utility of our algorithms with the help of results from our initial experiments (Section 5).

The algorithmic framework developed in this paper is powerful as it yields several decoding algorithms. At one end of the spectrum is a provably linear time algorithm for computing a suboptimal solution and at the other end is an exponential time algorithm for computingNIST Scores7 Logscoresmada. 2003. Fast decoding and optimal decoding for machine translation. Artificial Intelligence.Ulrich Germann. 2003. Greedy decoding for the optimal solution. We have also shown that alternating maximization can be employed tocome up with O (m2) decoding algorithm. Twoquestions in this connection are:1. Is it possible to reduce the complexity of AlternatingSearch to O (m)?2. Instead of exploring each alignment separately, is it possible to explore a bunch of alignments in one shot?Answers to these questions will result in faster and more efficient decoding algorithms.7.
